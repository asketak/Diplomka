na relaci adresy-outputy jsem pridal prvni radek: tx,address

smazal jsem bloky a adresy a neimportoval relace mezi nimy

/root/velke/neo4j-community-3.3.2/bin/neo4j-admin import  --nodes:Transaction transactions_header.csv,transactions.csv --nodes:Output outputs_header.csv,outputs.csv --nodes:Address addresses_header.csv,addresses.csv --relationships:OUTPUT rel_tx_output_header.csv,rel_tx_output.csv --relationships:INPUT rel_input_header.csv,rel_input.csv --relationships:USES rel_output_address_header.csv,rel_output_address.csv --ignore-missing-nodes=true


USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS FROM "file:/root/velke/blocks_500000_512700/rel_output_address.csv" as csvline
 merge(o:OUTPUT {txid_n : csvline.tx})
 on match set o.address = csvline.address
 on create set o.address = csvline.address


MATCH (start:Address {address: '1AEfmTfVsWMWhnw96FiF5jpzTy57wSQRjs'}),(end:Address {address: '3DXLG1GKr1arP6KCDgAS33Pn5ij4UiTJNA'})
return start,end;

  p = shortestpath((start)-[:INPUT|OUTPUT*]->(end))
  return p

WITH p
LIMIT 1
UNWIND nodes(p) as n
OPTIONAL MATCH (n)-[:USES]->(a)
RETURN n as node, a as address

CALL algo.pageRank('match (n) return id(n) as id','match (a)-[]-(b) return id(a) as source, id(b) as target', {graph:'cypher', concurrency:8, iterations:2, dampingFactor:0.85, write: true, writeProperty:'pagerank'});


opravdu zalezi na poradi
profile MATCH (start:Identity)-[]-(strt:Address )<-[:USES]-(o1:Output)
             -[:INPUT|OUTPUT*1..6]->(o2:Output)-[:USES]->(end:Address {address: '1AEfmTfVsWMWhnw96FiF5jpzTy57wSQRjs'}),
  p = shortestpath((o1)-[:INPUT|OUTPUT*1..6]->(o2))
  with start,p
  limit 1
  return start,p

profile MATCH (start:Identity)-[]-(strt:Address )<-[:USES]-(o1:Output)
             -[:INPUT|OUTPUT*1..8]->(o2:Output)-[:USES]->(end:Address {address: '1B9GeBaij3y9YsGr4h9qA43kib5oiSMwjf'}),
  p = shortestpath((o1)-[:INPUT|OUTPUT*1..8]->(o2))
  with start,p
  limit 10
  return start,p


  MATCH (start:Address{address: '1MnJK5LBmeFi1JHhqmF2fWJvFJpfEkfEfG'}), (end:Address{address: '1AEfmTfVsWMWhnw96FiF5jpzTy57wSQRjs'})
CALL algo.shortestPath.stream(start, end, 'cost')
YIELD nodeId, cost
RETURN nodeId, cost LIMIT 1



CALL algo.labelPropagation('', '','BOTH',
  {iterations:10,partitionProperty:'partition', write:true})
YIELD nodes, iterations, loadMillis, computeMillis, writeMillis, write, partitionProperty;

pred louvainem markni zdrojove nody jako jeden label


caspar@jumpy:~/nctest/a/mydir$ ls
file_a.txt  file_b.log
caspar@jumpy:~/nctest/a/mydir$ tar -cz . | nc -q 10 -l -p 45454
Computer 2

caspar@jumpy:~/nctest/b$ ls
caspar@jumpy:~/nctest/b$ nc -w 10 localhost 45454 | tar -xz
caspar@jumpy:~/nctest/b$ ls
file_a.txt  file_b.log


LOAD CSV WITH HEADERS FROM "file:///allid.csv" AS row
MERGE (a:Address {address: row.address})
CREATE (a)-[:HAS]->(i:Identity
  {name: row.tag, link: row.link})

  MATCH (n:Identity) OPTIONAL MATCH (n)-[r]-() DELETE n, r